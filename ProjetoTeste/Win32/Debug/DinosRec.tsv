start	end	text
0	8000	Alô, estou me ouvindo bem?
8000	10000	Choc!
10000	18000	Bom, então vamos lá pessoal, eu vou estar falando sobre Cloud com um Delphi, né?
18000	21000	Descomplicando, mostrando mais a parte prática da Cloud.
21000	25000	Deixa eu soltar aqui pro editor.
25000	29000	Certo, o que que eu vou estar abordando aqui hoje, né?
29000	37000	A gente vai estar vendo os monolitos, os microserviços, o que são as fases, as funções, as services, algumas arquiteturas.
37000	41000	O que que é o Google Cloud Platform, o GCP?
41000	43000	Vamos estar falando bem sobre o Cinto, sobre Docker.
43000	46000	Aí vamos entrar um pouco na parte prática.
46000	53000	Tem os contatos ali no final e vou abrir o espaço de dúvidas também no final.
53000	56000	Certo, pra quem não me conhece, eu sou o Daniel Fernandes.
56000	58000	Sou do Ovidor Senor aqui da AQUA.
58000	61000	Tenho mais de sete anos de experiência com o Delphi.
61000	65000	Sou graduado em gestão da TI pela FATEC de Braga São Paulo Lista.
65000	68000	Sou pós-graduado também em geria de software pela estácio.
68000	71000	Sou o criador do Dinos Devs no Instagram.
71000	77000	Fiz um componente que me levou pra conference no ano passado, que é o LibreOffice pra Delphi, que é o Dinos Offices.
77000	85000	E fui palestrante na DelphiCon de 2023, na conference do ano passado e desse ano também.
86000	88000	Certo, então vamos começar.
88000	90000	O que são os monolitos?
90000	95000	O monolito é uma arquitetura de software, onde todas as funcionalidades estão no local só.
95000	103000	Então aqui na representação do monolito, que a gente tem forma de pagamento, pedido, cadastro,
103000	108000	tudo numa única instância e essa instância, ela comunica com o único banco de dados.
108000	113000	E a interface de usuário consome essa instância do monolito.
113000	117000	Há alguns casos que a extensa do usuário está até dentro do monolito também.
119000	122000	E quais são as vantagens de se utilizar monolito?
122000	125000	É a simplicidade inicial na arquitetura.
125000	130000	Ele é bom pra criar MVPs, porque é bem fácil no começo do desenvolvimento.
130000	136000	A coisão da equipe de Devs, porque só utiliza uma única linguagem.
136000	142000	É simples pra fazer deploy na produção, porque ao atualizar um pedido,
142000	144000	você vai atualizar toda a instância dele.
144000	147000	Então você não tem que se preocupar com diversos serviços espalhados.
147000	151000	E é fácil pra debugar, porque toda regra de negócio está em um único local.
151000	157000	Tem até uma referência aqui do Martin Fowler, que ele fala pra se usar primeiro o monolito,
157000	159000	o monolito de first.
159000	163000	E nessa abordagem aqui que fala você para começar com o monolito.
163000	165000	Então há diversas discussões sobre...
165000	167000	Eu achei bem interessante o esporte dele.
169000	173000	E quais são os desafios dos monolitos?
173000	175000	Tudo está em um único local.
175000	179000	Então isso tem uma alta dependência,
179000	182000	que você não consegue mexer em uma única parte de seu software
182000	185000	sem afetar as demais camadas.
185000	190000	A alta dependência demora para um novo Devs habituar.
190000	193000	Então para aprender toda a regra de negócio,
193000	196000	você tem que entender o sistema como um todo,
196000	200000	uma boa parte dele para conseguir se habituar ao sistema.
200000	204000	As problemas de uma parte do software afeta ele como um todo.
204000	207000	Se você tem que atualizar um label ali no caixa,
207000	209000	você vai ter que atualizar todo o seu sistema,
209000	211000	só por conta de um leigo errado.
211000	215000	Abaixa a escalabilidade, justamente por isso,
215000	219000	você não consegue escalar também para ser reaproveitado.
219000	222000	Basos de dados normalmente são gigantes,
222000	225000	e utiliza-se uma única tecnologia.
227000	229000	E os microserviços?
229000	234000	Os microserviços veem entre aspas para resolver o problema do monolito.
234000	237000	Não estou aqui para definir monolito nem microserviços,
237000	240000	só colocando as abordagens aqui.
240000	245000	O microserviço também é um desenho de arquitetura de software,
245000	249000	onde são definidos conjuntos pequenos de serviços independentes,
249000	254000	cada um executa uma única funcionalidade específica.
254000	258000	E cada serviço é alpergado entre uma entidade.
258000	261000	Então aqui na representatividade dele,
261000	264000	a gente pegou aquele desenho do monolito
264000	266000	e passou ele para microserviços.
266000	268000	Então cada um ganha sua instância.
268000	272000	Aqui temos as vendas, os cadastros, os pedidos,
272000	276000	e cada monolito conversa agora com o seu próprio banco de dados.
276000	280000	Cada microserviço comunica-se com o seu próprio banco de dados.
284000	286000	E quais as vantagens?
286000	288000	Quando utilizarem os monolitos,
288000	291000	aqui tem uma outra representatividade dele.
291000	293000	É uma aplicação grande e complexa,
293000	296000	que precisa ser altamente escalada e dimensionada,
296000	300000	quando a aplicação possui muitos domínios e subdomínios,
300000	303000	e quando a necessidade de integração e implementação continua.
303000	306000	A gente vai ver um pouco mais a fundo esses tópicos também.
306000	310000	Aqui é um desenho de como a estrutura de um microserviço.
310000	312000	E aqui tem uma frase que eu achei bem legal,
312000	314000	que é vincular dos microserviços.
314000	317000	Não use uma basuca para matar uma formiga.
317000	319000	Então tem que analisar muito bem essa arquitetura
319000	321000	se vale a pena para o seu projeto.
323000	326000	E quais são as características do microserviço?
326000	329000	Dividir as tarefas de formas independentes
329000	332000	no serviço deve implementar apenas uma função,
332000	335000	a troca de serviço é feita de maneira ágil,
335000	339000	a comunicação pelos microserviços é feita via a page,
339000	343000	é construída através de pequenas responsabilidades,
343000	346000	tem características de ter depois automatizados,
346000	348000	isso depende mais do seu DevOps.
348000	351000	E pode-se usar várias linguagens diferentes.
351000	353000	Aqui tem uma representação também.
353000	355000	Aqui é o que vamos construir.
355000	358000	É um cliente, uma API Gateway,
358000	361000	um orquestrador de containers, o container,
361000	363000	o orquestrador vai ser o Google ArchPact,
363000	365000	o container é o Docker,
365000	369000	e aqui mostrando a possibilidade de utilizar diversas linguagens,
369000	371000	tipo Java, Quart, o Google,
371000	373000	e a comunicação com os bancos de dados.
373000	376000	No caso a gente vai utilizando o NoSQL,
376000	379000	ou utilizando uma Firebase.
381000	384000	E as vantagens de se utilizar um microserviço?
384000	387000	Isso. A escalabilidade é eficiente,
387000	390000	se conseguir escalar melhor essa software,
390000	393000	isso tem facilidade na manutenção.
393000	396000	Isso aqui é um ponto meio divergente também.
396000	398000	A tecnologia é diversificada,
398000	400000	essa facilidade na manutenção
400000	403000	é no sentido de você ter códigos menores para analisar.
403000	406000	Ele é resiliente e tolerante à falha,
406000	410000	então se você se preocupar com os acuplamentos,
410000	413000	o microserviço não vai parar o outro,
413000	416000	e no movimento em paralelo você consegue quebrar
416000	418000	o seu microserviço em vários microserviços,
418000	422000	então você tem a possibilidade de granularizar bem o seu software,
422000	425000	e a facilidade de escalabilidade horizontal,
425000	428000	que é isso de granularizar o software.
430000	432000	E os desafios?
432000	435000	A complexidade é devido do tamanho da arquitetura,
435000	437000	testes de refatoração,
437000	440000	esse ponto aqui e você tem input e você tem output,
440000	443000	e você tem pequenas séries de negócios no microserviço,
443000	447000	porém para você encontrar onde pode estar o problema,
447000	449000	é um pouco mais demorado.
449000	452000	O aumento de custo para resolver bugs,
452000	454000	o aumento de custo no sentido do tempo que o desenvolvedor
454000	456000	vai levar para encontrar onde dá o problema,
456000	458000	pode ser maior.
458000	462000	A latência, a comunicação é feita sempre via rede HTTP,
462000	465000	no caso o Google oferece o viciPi,
465000	468000	que é um consensus uma rede local dentro da cloud,
468000	472000	essa rede local você consegue colocar seus fases para se comunicarem,
472000	474000	então isso foi dos bastantes,
474000	476000	e a latência mais ainda assim estamos tratando de HTTP,
476000	478000	aquisições de HTTP,
478000	481000	então por isso uma desvantagem.
481000	485000	O gerenciamento de dados ao longo do prazo,
485000	488000	você vai ter vários bancos e em algum determinado momento
488000	490000	isso pode ser complexo de gerenciar,
490000	492000	e nem todos os aplicativos são grandes,
492000	494000	o suficiente para ser divididos em microserviços,
494000	496000	isso aqui vale muito levar em contas.
496000	499000	Na hora de escolher essa aplicação.
501000	504000	E as boas práticas do microserviço?
504000	507000	Cada serviço é uma arquitetura de microserviço,
507000	511000	possui o seu próprio bug de dados na sua arquitetura,
511000	515000	ou utiliza de preferência a comunicação acíncrona,
515000	518000	a comunicação dos microserviços deve ser realizada
518000	520000	de exposição de APIs,
520000	522000	de APIs REST,
522000	525000	que deve se evitar o acoplamento,
525000	527000	a pay gateway,
527000	530000	ela deve ser a centralização das autenticações,
530000	532000	rotas e balanceamentos de cargas,
532000	535000	logs, as limitações,
535000	537000	tudo deve acontecer dentro dela,
537000	539000	ela é como se um swagger,
539000	541000	o melhor ela é um swagger,
541000	544000	e evitar falhas em cascatas,
544000	547000	você evitando os apoclamentos do microserviço,
547000	549000	você não tendo dependências,
549000	551000	ou mínimas dependências de um microserviço para o outro,
551000	553000	você vai conseguir evitar falhas em cascatas,
553000	555000	então um microserviço não vai parar o outro
555000	558000	por deixar que o curso está falhando em algum momento.
560000	564000	E como que migra um monolito para um microserviço?
564000	569000	Primeiro, você extrai uma funcionalidade do seu monolito,
569000	571000	passe ele para o microserviço,
571000	573000	e você faz os testes,
573000	575000	você evita refaturar tudo de uma vez,
575000	580000	você deve primeiro pensar em desapoplar o serviço do monolito,
583000	587000	as organizações na hora de passagem do monolito para o microserviço
587000	589000	deve sempre pensar nas regras de negócio,
589000	591000	e não necessariamente na tecnologia,
591000	592000	nesse momento,
592000	595000	e ao migrar gradualmente os serviços,
595000	599000	pode-se utilizar um patrón chamado Tierra Database,
599000	602000	que você pega vários microserviços,
602000	604000	que você foi passando,
604000	606000	e reaproveita a base de dados,
606000	610000	e depois você vem desapoplando as bases de dados,
610000	615000	então compartilhar a base de dados entre os microserviços é algo temporário,
617000	621000	e o microserviço exige muita automação,
621000	624000	então deve-se pensar bastante,
624000	627000	não devolve-se nesse momento para fazer os bílgues,
627000	630000	criar as automatizações, as pipeline,
633000	634000	e o que eu faço?
635000	639000	Não dá para trabalhar com cloud microserviços e sem falar de faz,
639000	642000	faz um serviço de back-end, um servidor,
642000	645000	que não é um servidor,
645000	647000	vamos dizer ali, um serviço,
647000	649000	que vai ficar escutando,
649000	651000	e toda vez que chegar uma requisição HTTP,
651000	654000	ele vai expor esse serviço,
654000	656000	disparar um segundo o serviço,
656000	659000	e dar um retorno para a gente, e desligar,
659000	663000	e quais as vantagens de utilizar esse formato,
663000	665000	ou função, como serviço?
665000	668000	Você tem melhoria na idosa de desenvolvimento,
668000	673000	porque você não precisa se preocupar com a infraestrutura,
673000	676000	ela é toda gerenciada pelo produtor de cloud,
676000	679000	mas pela habilidade embutida,
679000	683000	então você também não precisa se preocupar com o tráfico,
683000	688000	com a indigência, isso também vai ser gerenciado pela cloud,
688000	691000	e a eficiência de custo, porque você não paga um servidor,
691000	693000	você não tem um servidor lá todo o tempo ligado,
693000	695000	uma máquina virtual,
695000	699000	você só vai pagar quando a requisição foi disparada,
699000	701000	levantou a sua função,
701000	703000	ela executou seu microserviço,
703000	705000	te deu um retorno e desligou,
705000	708000	a partir desse momento já não é cobrado mais custo,
708000	711000	é um taxímetro ali.
714000	716000	E quais os desafios do FAS?
716000	718000	Você tem menor controle do sistema,
718000	721000	porque você não tem acesso direto à infraestrutura,
721000	726000	então na hora de entender você pode ter uma certa complexidade,
726000	729000	e é mais complexo para a testa,
729000	732000	porque na hora de testar você vai ter que utilizar o ambiente local
732000	735000	e você vai ter que tentar reproduzir o mais real possível
735000	740000	o ambiente da cloud na sua máquina de testes,
740000	744000	e o service, o conceito dele.
744000	748000	O conceito do service é exatamente isso da área da FAS,
748000	750000	o service são implementados em contêneres
750000	752000	que são iniciados sobre demanda,
752000	755000	então a FAS é um service,
755000	759000	o service seria mais um conceito e o FAS seria algo mais palpável.
761000	765000	E aqui uma representação das arquiteturas,
765000	768000	aqui eu trouxe o FAS e o service só para comparar
768000	771000	que aqui é um cloud se pagando funções,
771000	776000	que é a mesma representação do service que é uma cloud se pagando funções.
776000	779000	Aqui é o que vamos construir, que eu já expliquei,
779000	783000	e aqui é como funciona o GCP para a gente trabalhar com as FAS.
783000	785000	A gente vai ter o cloud build,
785000	789000	que vai gerar o artifact que vai ser o nosso orquestrador de contêneres,
789000	791000	que vai guardar nossos dolares,
791000	794000	e a cloud run é o nosso FAS,
794000	798000	é o que vai ser disparado, que vai chamar os microservices.
801000	803000	E o que é o GCP?
803000	804000	O que é o Google Cloud?
804000	807000	O cloud nada mais é do que recursos físicos e virtuais
807000	810000	espalhados por todos os cantos do mundo,
810000	813000	e o Google Cloud Platform, que é o GCP,
813000	816000	ele é um provedor de recursos de computação em Google,
816000	818000	então ele é uma suíte de várias soluções,
818000	822000	a gente não vai conseguir ver nenhum por cento do que ele fornece,
822000	826000	acredito que para ver isso somente em uma certificação,
828000	832000	mas vamos utilizar aqui para trabalhar com o FAS.
832000	835000	E aqui são os comandos básicos que a gente vai utilizar,
835000	837000	que eu deixei aqui.
838000	841000	E aqui as bibliotecas que a gente vai utilizar nele,
841000	842000	que é o App Engine,
842000	845000	que ele é responsável pela criação dos aplicativos.
845000	848000	O cloud build, que é o construtor do aplicativo,
848000	853000	o artifact, que é o nosso orquestrador,
854000	857000	o cloud run, que é a nossa FAS,
857000	860000	ele é o que vai disparar o serviço,
860000	865000	e o IAM é o que controla as permissões.
867000	870000	E aí só para a gente fechar aqui a parte teórica,
870000	872000	sobre o que é o Docker,
872000	875000	o Docker são containers virtuais
875000	878000	que você consegue rodar imagens do sistema professional,
878000	880000	pode rodar Windows,
880000	882000	pode rodar Windows, pode rodar Mac.
882000	884000	Eu estou utilizando o Linux, porque não faz sentido
884000	888000	num teste você pagar uma licença Windows,
888000	890000	mas eu não vou entrar nesse método do sistema professional,
890000	892000	da compilação, para compilar o delft para Linux,
892000	894000	você pode utilizar o Pa server,
894000	896000	tem bastante vídeo no internet sobre ele.
897000	900000	E aqui tem os comandos básicos do Docker,
900000	901000	porque a gente vai utilizar,
901000	905000	eu deixei esse, e esse sudo Docker build aqui,
906000	909000	felizado, porque a gente vai utilizar ele dentro da cloud,
909000	911000	não vai dar tempo de mostrar ele,
911000	915000	rodando no nosso ambiente local.
916000	920000	Então, como diz o Linux,
920000	922000	tal que este show me decode,
922000	924000	vamos para a parte prática.
926000	928000	Então, aqui no delft,
929000	931000	o delft não tem nada demais nele,
931000	933000	aqui é a minha pay gate,
933000	935000	vamos construir,
935000	936000	só voltar aqui,
936000	938000	aqui é a minha pay gate.
938000	941000	Então, aqui é apenas um Morse,
941000	944000	estou dando na porta 8080,
944000	947000	com os cores ativos,
947000	949000	onde temos as nossas fotos.
956000	958000	E aqui nas fotos,
958000	961000	eu estou indicando os verbos HTTPs que eu vou estar utilizando,
961000	964000	que é o get, post, boot, delet,
964000	966000	e o path,
966000	968000	e para cada,
968000	970000	para cada verba HTTP,
970000	972000	eles são rest,
972000	974000	para dentro do meu microservice.
974000	976000	No caso aqui,
976000	978000	eu tenho um endereço que o cloud me fornece,
978000	980000	mas é minha ORI.
980000	982000	E este aqui é a minha pay gate,
982000	985000	então ela vai cuidar da volta do meu microservice,
986000	989000	e aqui é o meu microservice de delivery,
989000	990000	que é o exemplo que eu criei.
990000	991000	Também é um Morse,
991000	993000	estou dando na porta 8080,
993000	994000	o mesmo critério,
994000	995000	tem as minhas ORIs,
995000	998000	que são os meus verbos HTTPs,
998000	1000000	e dispara uma requisição aqui,
1000000	1001000	no caso aqui,
1001000	1004000	ele está disparando para o meu Firebase,
1004000	1006000	que é o meu banco de dados aqui.
1008000	1010000	Certo,
1010000	1012000	então vamos para,
1012000	1014000	vamos para a nuvem.
1014000	1018000	Aqui não consegui ativar todos os serviços aqui,
1018000	1019000	porque leva um bom tempo,
1019000	1021000	só para criar o cloud build,
1021000	1023000	ali em uns 10 minutos.
1023000	1025000	Então aqui dentro da cloud,
1025000	1027000	é só dar um novo projeto,
1027000	1029000	porque eu já tenho um criado aqui,
1029000	1031000	eu estou utilizando o meu projeto,
1031000	1032000	não tem nada de mais,
1032000	1034000	é só ir seguindo o que vai pedir,
1034000	1036000	praticamente um next-next finish ali.
1036000	1041000	E para você ativar as bibliotecas que eu citei aqui,
1041000	1043000	que está aqui,
1043000	1045000	é só escrever o nome delas,
1045000	1047000	o App Engine,
1051000	1053000	é só escrever aqui o App Engine,
1053000	1055000	e ele vai aparecer por aqui.
1057000	1059000	Aqui o App Engine,
1059000	1060000	no caso do App Engine,
1060000	1061000	na hora de criar,
1061000	1063000	ele é a única atenção dele que você tem que colocar na linguagem
1063000	1064000	que ele fosse estar,
1064000	1065000	vai estar lá para,
1065000	1067000	então, JavaScript,
1067000	1069000	PHP, você coloca em outros,
1069000	1071000	e o ambiente dele vai ser flexível.
1071000	1072000	O outros,
1072000	1075000	quer dizer que a gente vai utilizar binários,
1075000	1080000	e o flexível quer dizer que a gente vai utilizar os containers.
1080000	1083000	Então é só clicar nele e fazer a criação dele,
1083000	1085000	o mesmo a gente vai utilizar para o cloud build,
1085000	1088000	é só escrever o cloud build aqui,
1088000	1090000	porque ele vai sugerir para você,
1090000	1091000	você vai só ativar também,
1091000	1093000	vai só dar um Enable nele,
1093000	1096000	e é só seguir esses mesmos passos para todos aqui.
1096000	1099000	Não precisa criar um tipo de configuração nele,
1099000	1100000	só o App Engine que você vai ter que apontar
1100000	1103000	aquela linguagem flexível,
1103000	1106000	e após ter ativado todos,
1106000	1109000	a gente vai vir aqui,
1109000	1113000	e vai entrar no Google Shell,
1113000	1117000	e vai levar um tempinho que só vai iniciar a máquina,
1117000	1119000	e eu vou abrir em uma lateral aqui,
1119000	1124000	para a gente ter uma aba dedicada para o console.
1134000	1136000	Aqui dentro do console,
1136000	1140000	eu vou indicar o meu projeto,
1140000	1143000	que é esse projeto de livro que eu criei aqui,
1143000	1146000	esse que está apontado aqui,
1146000	1148000	e aí aqui dentro,
1148000	1149000	a gente vai clicar nesse lá,
1149000	1151000	precisinho aqui para abrir o editor,
1151000	1154000	por padrão, toda vez que a gente cria um projeto,
1154000	1156000	o Google ele já cria uma pasta para a gente,
1156000	1161000	então é só vir aqui no open folder,
1161000	1164000	e aqui eu criei uma pasta chamada de livro,
1164000	1167000	e eu vou abrir ela.
1171000	1173000	Aqui, no meu arquivo locais,
1173000	1176000	eu tenho os dois compilados do Delfin,
1176000	1180000	que é a mpd8 e meu microservice,
1180000	1182000	e que são os binários do Linux,
1182000	1184000	que eu estou utilizando no WSL,
1184000	1185000	estou utilizando o Linux aqui,
1185000	1188000	que é o Google que estou rodando,
1188000	1190000	eu vou precisar do meu app,
1190000	1192000	e o meu cloud build em,
1192000	1194000	e o docker file,
1194000	1196000	então o que a gente vai fazer com esses arquivos,
1196000	1200000	a gente vai passar aqui para dentro do cloud,
1200000	1204000	no caso eu criei aqui uma pasta chamada apg8,
1204000	1207000	e uma pasta do delivery do microservice,
1207000	1210000	e no caso aqui é só rastar para o navegador,
1210000	1212000	eu já economizei um tempo aqui de subir o upload,
1212000	1214000	deixa eu deixar ele aqui,
1214000	1217000	e como que funcionam essas estruturas,
1217000	1219000	esse app M aqui,
1219000	1223000	é o que indica para o nosso app engine,
1223000	1227000	que ele está funcionando em um ambiente flexível,
1227000	1229000	aqui de containers,
1229000	1232000	e o runtime dele é um custom,
1232000	1234000	porque vai ser um binário,
1234000	1236000	no caso se fosse Python, ele teria Python,
1236000	1238000	ele é a versão do comprador do Python,
1238000	1241000	aqui o nosso cloud build,
1241000	1245000	aqui eu estou apontando para o serviço do docker,
1245000	1247000	dentro da cloud,
1247000	1249000	e lembra que eu deixei aqui,
1249000	1251000	marcado no docker,
1251000	1253000	esse comando eu subo,
1253000	1255000	e o docker build-d,
1255000	1258000	isso aqui é o comando que a gente utiliza para criar o docker,
1258000	1261000	então no caso eu estou apontando para o Google,
1261000	1262000	que nos argumentos dele,
1262000	1264000	o que eu quero que o docker faça,
1264000	1266000	que é o build-d,
1266000	1268000	dentro do meu repositório,
1268000	1271000	e a imagem que eu quero que ele crie,
1271000	1274000	e aqui eu estou só apontando qualquer imagem,
1275000	1277000	e para ele criar essa imagem para mim,
1277000	1279000	ele precisa desse arquivo aqui,
1279000	1281000	o docker file,
1281000	1283000	dentro do docker file,
1283000	1284000	para você utilizar o docker,
1284000	1287000	você vai ter que ter uma conta aqui no docker hub,
1287000	1289000	e aqui no docker hub,
1289000	1292000	eu estou utilizando essa imagem do Ubuntu,
1292000	1297000	e aqui dentro do Ubuntu estou utilizando a versão 2204 dele,
1297000	1300000	então eu estou dizendo tudo isso na minha cloud,
1300000	1303000	que eu quero pegar o Ubuntu 22.4,
1303000	1306000	que ele vai ser apontado para essa imagem,
1306000	1310000	e aqui os runs são os passos que vão ser criados,
1310000	1313000	então eu estou dizendo que para ele criar,
1313000	1315000	depois que ele baixar a imagem,
1315000	1318000	ele vai dar uma apt-get update para atualizar o sistema operacional,
1318000	1320000	e vai instalar essas links,
1320000	1322000	como eu estou trabalhando com o horse,
1322000	1323000	eu estou trabalhando com o HTTP,
1323000	1326000	e eu preciso do ssr e do kernel aqui,
1326000	1329000	então essas duas bibliotecas que são bem importantes,
1329000	1333000	e essas são meio que padrões do docker.
1333000	1336000	Estou pedindo para ele criar uma pasta chamada web,
1336000	1337000	dar uma mkdir aqui,
1337000	1340000	para quem fez os cursinhos de semideira,
1340000	1342000	é o mesmo comando,
1342000	1345000	estou pedindo para ele copiar aqui a minha pg8,
1345000	1348000	que é o meu binário para dentro da pasta f,
1348000	1350000	então eu estou pegando de fora,
1350000	1352000	e passando para dentro do container que ele vai criar.
1352000	1356000	Aqui eu estou chmodi para dar a permissão do Linux,
1356000	1358000	então estou dando a renúncia hmodi aqui
1358000	1361000	para eu ter permissão no meu binário,
1361000	1364000	dizendo que eu vou expor o meu container na porta 8080,
1364000	1367000	que é a porta que o horse está escutando,
1367000	1369000	e aqui eu estou dizendo que a minha workdir,
1369000	1372000	que é para eu posicionar na minha porta,
1372000	1376000	na minha pasta app,
1376000	1378000	então quando for levantado a container,
1378000	1380000	eu vou estar na porta app,
1380000	1384000	e eu vou dar um cmd.bpg8,
1384000	1389000	esse cmd.bpg8 é para instartar o binário dentro do Linux,
1389000	1392000	e o mesmo aqui é a mesma configuração que prometa o serviço,
1392000	1394000	no caso do acerfile dele,
1394000	1397000	a única diferença é que ele está passando o binário
1397000	1402000	do micro serviço para dentro do container.
1402000	1404000	E aqui no shell,
1404000	1407000	a gente tem que só que entrar na raiz
1407000	1409000	onde está o cloudbuild,
1409000	1411000	e a gente vai instartar ele,
1411000	1416000	vamos dar um cmd.bpg8,
1416000	1418000	e vamos entrar aqui na nossa pg8,
1418000	1425000	então cmd.bpg8,
1425000	1430000	ele aqui de sensitive.
1430000	1432000	E esse para ver o diretório,
1432000	1435000	certo, estou aqui, tenho o binário,
1435000	1437000	e as umas arquivas de configuração,
1437000	1440000	o cloudbuild, o app está apontando o app engine,
1440000	1442000	o cloudbuild vai chamar o Dockerfile,
1442000	1445000	e vai fazer a construção.
1445000	1447000	Para criar um repositório,
1447000	1449000	no meu caso aqui,
1449000	1454000	eu vou entrar no artifacts aqui,
1454000	1456000	que é o nosso orquestrador,
1456000	1459000	eu já criei a minha paixinha com o repositório,
1459000	1462000	que é o meu Dockerhackle aqui.
1462000	1465000	E para fazer essa criação,
1465000	1468000	ele vai estar aqui dentro.
1468000	1470000	É esse comando aqui para criar o repositório,
1470000	1474000	que é o de cloud, artifacts, repositories,
1474000	1477000	create.hackle,
1477000	1480000	e é só rodar esse comando aqui dentro da cloud,
1480000	1482000	não é uma coisa que ele vai na falha,
1482000	1485000	porque ele vai dizer que eu já tenho esse repositório.
1485000	1487000	Quando roda o primeiro comando dentro de uma pasta,
1487000	1489000	ele perde uma autorização,
1489000	1491000	é só clicar em autorizar,
1491000	1494000	ele vai rodar com a conta aqui do Google,
1494000	1497000	e aqui está o Dockerhackle,
1497000	1500000	que é o que eu já criei,
1500000	1503000	e ele guarda o meu container.
1503000	1507000	Caso eu vou ter dois containers aqui dentro.
1507000	1510000	Caso ele só der um erro dizendo que já existe,
1510000	1512000	que existe.
1512000	1514000	E para criar esse container,
1514000	1515000	como funciona,
1515000	1518000	é esse comando aqui de cloudbuildsubmit,
1518000	1521000	eu vou chamando o configurador,
1521000	1524000	e vou apontar para o meu cloudbuild,
1524000	1526000	que é o cloudbuild dessa pasta aqui.
1526000	1528000	Então ele vai executar só esses arquivos aqui.
1528000	1530000	Aí depois se repete o mesmo processo
1530000	1532000	para o meu outro microservice.
1532000	1535000	Então, ao rodar ele aqui,
1535000	1538000	ele vai começar a fazer a criação.
1542000	1544000	O container cria aqui, o que ele vai fazer?
1544000	1545000	Ele vai criar uma imagem,
1545000	1548000	e nessa imagem você consegue
1548000	1550000	controlar suas versões.
1550000	1553000	Aqui eu tenho as versões anteriores,
1553000	1555000	e aqui eu tenho a última que eu testei,
1555000	1556000	que foi a 22 horas atrás.
1556000	1558000	No suporto eu estou subindo uma versão,
1558000	1560000	e ela está com bug,
1560000	1561000	e eu preciso voltar.
1561000	1564000	É só eu vim apontar para o container anterior,
1564000	1566000	que está com a versão anterior do meu binário.
1566000	1568000	E você não precisa parar
1568000	1570000	em nenhum momento o seu cliente.
1570000	1572000	Então se você tem, sei lá,
1572000	1574000	10 mil clientes pendurados,
1574000	1575000	ele não subir para o serviço,
1575000	1576000	ele está bugado,
1576000	1577000	e você tem 1 ou 2 mil clientes.
1577000	1579000	Você atualiza,
1579000	1583000	e aí ele espera todas as requisições anteriores terminar,
1583000	1585000	e ele passa para a nova.
1585000	1588000	Enquanto está aqui, ele...
1593000	1594000	A hora que se pode dar,
1594000	1596000	ele sempre vai dar um erro, não é?
1607000	1609000	Eu acho que...
1609000	1611000	eu zoei o meu...
1611000	1613000	meu apetite.
1625000	1627000	A gente só vê o que aconteceu aqui.
1627000	1637000	A gente está procurando o meu...
1645000	1648000	E após criar aqui o container,
1648000	1651000	a gente vai vincular o container com a nossa cloud,
1651000	1654000	então vai executando e eu vou correndo aqui.
1657000	1660000	Aqui dentro, para criar uma cloud LAN,
1660000	1661000	que é a nossa faz,
1661000	1663000	é só dar um criar serviço aqui.
1663000	1665000	Como eu já tenho ele,
1665000	1666000	então eu não vou criar dos animais,
1666000	1668000	eu vou mostrar aqui como funciona.
1668000	1670000	É só selecionar o container
1670000	1671000	que você acabou de criar,
1671000	1673000	no caso da versão dele,
1673000	1675000	ele vai ir para o propiastrador,
1675000	1676000	vai expandindo,
1676000	1678000	vai pegar o container,
1678000	1680000	e aqui é a última que eu tenho aqui,
1680000	1682000	quando você está buildando a outra ali,
1682000	1684000	e você seleciona ela.
1684000	1686000	Então você apontou aqui sua cloud,
1686000	1688000	a sua cloud LAN toda vez que ela for chamada,
1688000	1690000	vai disparar esse container.
1690000	1692000	E a...
1692000	1694000	e o que você está dizendo,
1694000	1696000	que já tem nos distâncias
1696000	1698000	e o tipo de autenticação,
1698000	1700000	no caso eu estou utilizando autenticação
1700000	1702000	direto na pgtwin.
1702000	1704000	Então eu só abrir a minha pgtwin,
1704000	1706000	que eu já tenho criado aqui.
1707000	1709000	Agora ele está rodando certinho aqui.
1709000	1711000	Ele já começou a dar os steps aqui,
1711000	1714000	que são os runs que eu apontei
1714000	1716000	aqui no Dockerfine.
1719000	1721000	E aqui dentro,
1721000	1723000	o que acontece quando a gente implementa?
1723000	1725000	Ele ganha uma URL aqui.
1725000	1727000	Então eu vou trabalhar
1727000	1729000	com essa URL toda vez que eu chamar
1729000	1731000	essa URL barra,
1731000	1733000	o que está dentro do meu Docker,
1733000	1735000	que eu defini aqui no Delphi,
1735000	1737000	no caso da minha pgtwin.
1737000	1739000	No caso da minha pgtwin,
1739000	1741000	ela está escutando na URL
1741000	1743000	de DelphiMS pedidos.
1743000	1745000	Então toda vez que eu chamar essa URL
1745000	1747000	aqui,
1747000	1749000	ele vai disparar no caso aqui um...
1749000	1751000	ele vai disparar
1751000	1753000	aqui um dos verbos HTTP,
1753000	1755000	que está rodando
1755000	1757000	no microservice do container.
1759000	1760000	E...
1760000	1762000	deixa eu ver se ele já rodou,
1762000	1764000	já rodou agora os statususas.
1764000	1765000	Então aqui,
1765000	1767000	eu vou dar someditar a implementação.
1767000	1769000	No caso não tem como configurar,
1769000	1771000	a implementação continua.
1771000	1773000	Aqui você aponta para um repositório do Git
1773000	1775000	e toda vez que você dá um PR nele,
1775000	1777000	ele já atualiza para você.
1777000	1779000	É como uma fina de...
1779000	1781000	de conhecimento,
1781000	1783000	para a gente ver como funciona.
1783000	1785000	Estou fazendo aqui na mão.
1785000	1787000	Tô dizendo que a porta do meu container
1787000	1789000	que já é 8080,
1789000	1791000	então a Cláudia Ubuntu
1791000	1793000	tem que estar escutando aqui.
1793000	1795000	E aqui,
1795000	1797000	legal,
1797000	1798000	eu vou deixar.
1798000	1799000	E esse aqui é o front,
1799000	1801000	que é reconfigurado em Android.
1801000	1803000	Esse front só para...
1803000	1805000	antes de eu atualizar aqui,
1805000	1807000	eu tenho essa classe aqui onde estão os meus verbos.
1809000	1811000	E ele erda dessa classe aqui
1811000	1813000	que só está aguardando a URL.
1813000	1815000	A URL com a URL.
1815000	1817000	Então,
1817000	1819000	ele vai chamar a minha perigueita
1819000	1821000	e vai chamar
1821000	1823000	o microserviço de delivery.
1823000	1825000	E o microserviço de delivery vai comunicar
1825000	1827000	o microserviço.
1827000	1829000	Toda vez que eu abro essa página aqui,
1829000	1831000	ela dá um get.
1831000	1833000	Então, eu só vou separar aqui
1833000	1835000	e vou deixar esse cara aqui.
1839000	1841000	Vou melhorar aqui a disposição.
1841000	1843000	Então, eu selecionei aqui a nova versão
1843000	1845000	do...
1845000	1847000	do container.
1849000	1851000	Aqui está,
1851000	1853000	que agora já é 2 minutos atrás.
1853000	1855000	E vou dar um implementar.
1857000	1859000	Olha que bacana, ele está implementando.
1859000	1861000	A Cláudia Luana, que ela está em atualização
1861000	1863000	e eu não perdi o acesso.
1863000	1865000	Meu get funcionando.
1865000	1867000	E olha aqui, ele trabalhando.
1867000	1869000	Meus equisições estão 100% na versão anterior
1869000	1871000	de 22 horas atrás, que é o que está com o flagzinho aqui.
1871000	1873000	E eu não perdi.
1873000	1875000	Eu consigo fazer até um post aqui.
1875000	1877000	Para qualquer coisa.
1879000	1881000	Dá um incluir aqui.
1881000	1883000	O outro post,
1883000	1885000	foi, inclusive, pedido 3 aqui,
1885000	1887000	de uma pedida no Firebase.
1887000	1889000	Ele continua trabalhando
1889000	1891000	e assim que ele terminar,
1891000	1893000	aqui, olha, ele atualizou.
1893000	1895000	Agora, 100% das equisições já estão na nova versão.
1897000	1899000	Esse daqui é a Pegate, o que está chamando
1899000	1901000	a outra Cloud Run.
1901000	1903000	E o processo para atualizar essa Cloud Run
1903000	1905000	é a mesma.
1905000	1907000	Então, eu só vim aqui em um shell.
1907000	1909000	Mas eu vou voltar a pasta
1909000	1911000	para ter que ser de dois pontos.
1911000	1913000	O LCD.
1913000	1915000	Pedidos.
1915000	1917000	Underline.
1917000	1919000	B,
1919000	1921000	R,
1921000	1923000	C,
1923000	1925000	R,
1925000	1927000	C.
1927000	1929000	E eu vou botar esse comando do Cloud Build
1929000	1931000	e só me chamando o Cloud Build dele aqui.
1931000	1933000	Quanto ele está executando aqui.
1933000	1935000	E uma coisa que a gente viu nas boas práticas,
1935000	1937000	né?
1937000	1939000	Apenas a Pegate deve estar disposta
1939000	1941000	e o microserviço não.
1941000	1943000	Os microserviços dentro do orquestrador lá
1943000	1945000	não deve estar.
1945000	1947000	Tivesse mais microserviços dentro desse container.
1947000	1949000	E aqui,
1949000	1951000	dentro da
1951000	1953000	do próprio Google,
1953000	1955000	que se eu executar o comando,
1955000	1957000	ele vai dar um get, né?
1957000	1959000	Então, se eu chamar aqui,
1959000	1961000	eu vou chamar o meu container.
1961000	1963000	Um pedido de Firebase,
1963000	1965000	olha, 100% de acesso.
1965000	1967000	A Pegate eu não sei que chamar ele.
1971000	1973000	Só esperar terminar de atualizar o container.
1979000	1981000	Ele está terminando o Build aqui.
1989000	1991000	Aqui os steps do
1991000	1993000	do upper file.
1995000	1997000	Criando
2003000	2005000	uma target dele.
2005000	2007000	E finalizou
2007000	2009000	criação.
2009000	2011000	E aqui,
2011000	2013000	a gente vai fazer o mesmo esquema.
2013000	2015000	A gente está
2015000	2017000	a nossa Cloud Run do microserviço.
2019000	2021000	Vem pro orquestrador.
2021000	2023000	Criando
2027000	2029000	e vou selecionar aqui a última
2029000	2031000	versão que eu criei.
2031000	2033000	E ao salvar,
2033000	2035000	vou implementar aqui.
2035000	2037000	Mesma coisa, o mesmo microserviço que está lá
2037000	2039000	utilizando direto, o Firebase,
2039000	2041000	continuar funcionando.
2043000	2045000	Se eu
2045000	2047000	alterar aqui,
2047000	2049000	ele continua funcionando
2049000	2051000	enquanto ele implementa
2051000	2053000	a nova versão.
2053000	2055000	Enquanto todos os usuários estão
2055000	2057000	trabalhando aqui dentro
2057000	2059000	da versão anterior até
2059000	2061000	de atualizar de vez.
2061000	2063000	E o que é legal aqui também,
2063000	2065000	se eu consigo acessar as métricas
2065000	2067000	enquanto ele atualiza,
2067000	2069000	deixa eu ter que esperar.
2069000	2071000	Não consigo assim.
2071000	2073000	Opa!
2073000	2075000	Como é que deu uma trabadinha aqui?
2077000	2079000	E aqui a gente tem
2079000	2081000	os relatórios
2081000	2083000	para a gente ter tomadas de decisões
2083000	2085000	da Cloud, de como está
2085000	2087000	as solicitações.
2087000	2089000	A gente vai terminar de
2089000	2091000	pedir não a regrupas da chuva.
2091000	2093000	Mas aqui ele vai ter
2093000	2095000	a pontagem de solicitações
2095000	2097000	de containers.
2097000	2099000	De quantas instâncias ele precisou
2099000	2101000	utilizar?
2107000	2109000	A latência que foi, as demoras,
2109000	2111000	você consegue ter
2111000	2113000	uma série de informações
2113000	2115000	da utilização do sumir para o serviço.
2115000	2117000	Porque toda a estrutura
2117000	2119000	da sua infraestrutura
2119000	2121000	é controlada
2121000	2123000	pelo Google Cloud.
2125000	2127000	Bom pessoal,
2127000	2129000	é isso.
2129000	2131000	Eu não vou entrar tantos detalhes
2131000	2133000	aqui dos relatórios.
2133000	2135000	Ele é bem auto-explicativo.
2135000	2137000	E espero ter conseguido
2137000	2139000	realmente descomplicar a Cloud
2139000	2141000	principalmente utilizando Delphi,
2141000	2143000	que não é uma abordagem muito comum
2143000	2145000	para a gente,
2145000	2147000	que é do meio do Delphi.
2147000	2149000	A gente é mais acostumado
2149000	2151000	com os monolitos, mas a gente
2151000	2153000	consegue trabalhar assim
2153000	2155000	no novo formato
2155000	2157000	e
2157000	2159000	é isso, pessoal.
2159000	2161000	Se alguém tiver dúvidas,
2161000	2163000	quiser perguntar
2163000	2165000	um momento e agora.
2165000	2167000	Vou parar a gravação aqui.
